/**
 * Enhanced Vulnerability Scanner Tests
 * Tests for the enhanced vulnerability scanning with secret detection
 */

import { describe, it, expect, beforeEach, vi } from 'vitest';
import { VulnerabilityScanner } from '../../../src/integration/security/vulnerability-scanner';
import { VulnerabilityConfig, ScanTarget } from '../../../src/integration/security/types';

describe('Enhanced Vulnerability Scanner', () => {
  let scanner: VulnerabilityScanner;
  let mockConfig: VulnerabilityConfig;

  beforeEach(() => {
    mockConfig = {
      scanners: [
        {
          name: 'secret-scanner',
          type: 'secret',
          config: { enabled: true },
          enabled: true
        },
        {
          name: 'code-scanner',
          type: 'code',
          config: { enabled: true },
          enabled: true
        }
      ],
      schedules: [],
      policies: [],
      reporting: {
        dashboards: true,
        alerts: true,
        reports: true,
        integration: []
      }
    };

    scanner = new VulnerabilityScanner();
  });

  describe('Secret Detection Integration', () => {
    it('should initialize with secret detector', async () => {
      await expect(scanner.initialize(mockConfig)).resolves.not.toThrow();
    });

    it('should perform secret scans on file targets', async () => {
      await scanner.initialize(mockConfig);

      const target: ScanTarget = {
        type: 'file',
        identifier: 'test-file.js'
      };

      // Mock the secret detector to avoid file system operations
      const result = await scanner.scanSystem(target);

      expect(result).toBeDefined();
      expect(result.target).toEqual(target);
      expect(result.vulnerabilities).toBeDefined();
      expect(Array.isArray(result.vulnerabilities)).toBe(true);
    });

    it('should perform secret scans on directory targets', async () => {
      await scanner.initialize(mockConfig);

      const target: ScanTarget = {
        type: 'directory',
        identifier: '/test/directory'
      };

      const result = await scanner.scanSystem(target);

      expect(result).toBeDefined();
      expect(result.target).toEqual(target);
      expect(result.vulnerabilities).toBeDefined();
    });

    it('should convert secret matches to vulnerabilities', async () => {
      await scanner.initialize(mockConfig);

      const target: ScanTarget = {
        type: 'file',
        identifier: 'secrets.env'
      };

      const result = await scanner.scanSystem(target);

      // Check that vulnerabilities have the expected structure
      for (const vuln of result.vulnerabilities) {
        expect(vuln).toHaveProperty('id');
        expect(vuln).toHaveProperty('title');
        expect(vuln).toHaveProperty('description');
        expect(vuln).toHaveProperty('severity');
        expect(vuln).toHaveProperty('cvss');
        expect(vuln).toHaveProperty('category');
        expect(vuln).toHaveProperty('solution');
        expect(vuln).toHaveProperty('references');
        
        if (vuln.category === 'secret') {
          expect(vuln.title).toContain('Hardcoded');
          expect(vuln.solution).toContain('environment variables');
          expect(vuln).toHaveProperty('metadata');
        }
      }
    });

    it('should map secret severity correctly', async () => {
      await scanner.initialize(mockConfig);

      const target: ScanTarget = {
        type: 'file',
        identifier: 'test.js'
      };

      const result = await scanner.scanSystem(target);

      // Verify severity mapping
      for (const vuln of result.vulnerabilities) {
        expect(['critical', 'high', 'medium', 'low']).toContain(vuln.severity);
        
        if (vuln.severity === 'critical') {
          expect(vuln.cvss).toBeGreaterThanOrEqual(9.0);
        } else if (vuln.severity === 'high') {
          expect(vuln.cvss).toBeGreaterThanOrEqual(7.0);
        } else if (vuln.severity === 'medium') {
          expect(vuln.cvss).toBeGreaterThanOrEqual(4.0);
        }
      }
    });
  });

  describe('Enhanced Vulnerability Detection', () => {
    it('should detect multiple vulnerability types', async () => {
      await scanner.initialize(mockConfig);

      const target: ScanTarget = {
        type: 'application',
        identifier: 'test-app'
      };

      const result = await scanner.scanSystem(target);

      expect(result.vulnerabilities).toBeDefined();
      
      // Should potentially find different types of vulnerabilities
      const categories = new Set(result.vulnerabilities.map(v => v.category));
      expect(categories.size).toBeGreaterThan(0);
    });

    it('should provide comprehensive vulnerability metadata', async () => {
      await scanner.initialize(mockConfig);

      const target: ScanTarget = {
        type: 'file',
        identifier: 'vulnerable-file.js'
      };

      const result = await scanner.scanSystem(target);

      for (const vuln of result.vulnerabilities) {
        // Check required fields
        expect(vuln.id).toBeDefined();
        expect(vuln.title).toBeDefined();
        expect(vuln.description).toBeDefined();
        expect(vuln.severity).toBeDefined();
        expect(vuln.category).toBeDefined();
        expect(vuln.solution).toBeDefined();
        expect(Array.isArray(vuln.references)).toBe(true);
        
        // Check CVSS score is reasonable
        expect(vuln.cvss).toBeGreaterThan(0);
        expect(vuln.cvss).toBeLessThanOrEqual(10);
      }
    });

    it('should generate scan summaries', async () => {
      await scanner.initialize(mockConfig);

      const target: ScanTarget = {
        type: 'directory',
        identifier: '/test/project'
      };

      const result = await scanner.scanSystem(target);

      expect(result.summary).toBeDefined();
      expect(result.summary.total).toBe(result.vulnerabilities.length);
      
      // Verify summary counts
      const actualCounts = {
        critical: result.vulnerabilities.filter(v => v.severity === 'critical').length,
        high: result.vulnerabilities.filter(v => v.severity === 'high').length,
        medium: result.vulnerabilities.filter(v => v.severity === 'medium').length,
        low: result.vulnerabilities.filter(v => v.severity === 'low').length
      };

      expect(result.summary.critical).toBe(actualCounts.critical);
      expect(result.summary.high).toBe(actualCounts.high);
      expect(result.summary.medium).toBe(actualCounts.medium);
      expect(result.summary.low).toBe(actualCounts.low);
    });
  });

  describe('Error Handling', () => {
    it('should handle secret detection failures gracefully', async () => {
      await scanner.initialize(mockConfig);

      const target: ScanTarget = {
        type: 'invalid-type' as any,
        identifier: 'invalid-target'
      };

      // Should not throw, but handle gracefully
      const result = await scanner.scanSystem(target);
      expect(result).toBeDefined();
    });

    it('should continue scanning other types when secret detection fails', async () => {
      await scanner.initialize(mockConfig);

      const target: ScanTarget = {
        type: 'network',
        identifier: '192.168.1.1'
      };

      const result = await scanner.scanSystem(target);
      
      // Should still perform other types of scans
      expect(result).toBeDefined();
      expect(result.vulnerabilities).toBeDefined();
    });
  });

  describe('Integration with Validation Pipeline', () => {
    it('should provide results compatible with validation framework', async () => {
      await scanner.initialize(mockConfig);

      const target: ScanTarget = {
        type: 'application',
        identifier: 'test-application'
      };

      const result = await scanner.scanSystem(target);

      // Verify the result structure is compatible with validation pipeline
      expect(result).toHaveProperty('scanId');
      expect(result).toHaveProperty('target');
      expect(result).toHaveProperty('startTime');
      expect(result).toHaveProperty('endTime');
      expect(result).toHaveProperty('vulnerabilities');
      expect(result).toHaveProperty('summary');
      
      // Verify timestamps
      expect(result.startTime).toBeInstanceOf(Date);
      expect(result.endTime).toBeInstanceOf(Date);
      expect(result.endTime.getTime()).toBeGreaterThanOrEqual(result.startTime.getTime());
    });

    it('should generate unique scan IDs', async () => {
      await scanner.initialize(mockConfig);

      const target: ScanTarget = {
        type: 'file',
        identifier: 'test.js'
      };

      const result1 = await scanner.scanSystem(target);
      const result2 = await scanner.scanSystem(target);

      expect(result1.scanId).not.toBe(result2.scanId);
    });
  });

  describe('Performance and Scalability', () => {
    it('should handle large numbers of vulnerabilities', async () => {
      await scanner.initialize(mockConfig);

      const target: ScanTarget = {
        type: 'directory',
        identifier: '/large/project'
      };

      const startTime = Date.now();
      const result = await scanner.scanSystem(target);
      const duration = Date.now() - startTime;

      // Should complete in reasonable time (less than 10 seconds for tests)
      expect(duration).toBeLessThan(10000);
      expect(result).toBeDefined();
    });

    it('should provide progress information for long-running scans', async () => {
      await scanner.initialize(mockConfig);

      const target: ScanTarget = {
        type: 'directory',
        identifier: '/complex/project'
      };

      const result = await scanner.scanSystem(target);

      // Should include timing information
      expect(result.startTime).toBeDefined();
      expect(result.endTime).toBeDefined();
      expect(result.endTime.getTime() - result.startTime.getTime()).toBeGreaterThan(0);
    });
  });
});