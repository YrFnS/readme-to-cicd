/**
 * Output Handler Integration Tests
 * 
 * Integration tests to verify OutputHandler works correctly with ComponentOrchestrator
 */

import { describe, it, expect, beforeEach, vi } from 'vitest';
import * as fs from 'fs/promises';
import { OutputHandler, WorkflowFile } from '../../../src/cli/lib/output-handler';
import { Logger } from '../../../src/cli/lib/logger';

// Mock fs module
vi.mock('fs/promises');
const mockFs = vi.mocked(fs);

// Mock logger
const mockLogger = {
  debug: vi.fn(),
  info: vi.fn(),
  warn: vi.fn(),
  error: vi.fn()
} as unknown as Logger;

describe('OutputHandler Integration', () => {
  let outputHandler: OutputHandler;

  beforeEach(() => {
    vi.clearAllMocks();
    outputHandler = new OutputHandler(mockLogger);
  });

  it('should integrate with ComponentOrchestrator workflow', async () => {
    // Simulate workflow files generated by YAML Generator
    const workflowFiles: WorkflowFile[] = [
      {
        filename: 'ci.yml',
        content: `name: CI
on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
      - run: npm ci
      - run: npm test`,
        type: 'ci',
        metadata: {
          description: 'Continuous Integration workflow',
          version: '1.0.0',
          generated: new Date()
        }
      },
      {
        filename: 'cd.yml',
        content: `name: CD
on:
  push:
    branches: [main]
jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Deploy to production
        run: echo "Deploying..."`,
        type: 'cd',
        metadata: {
          description: 'Continuous Deployment workflow',
          version: '1.0.0',
          generated: new Date()
        }
      }
    ];

    const outputDir = '.github/workflows';
    
    // Mock directory operations
    mockFs.stat.mockResolvedValueOnce({
      isDirectory: () => true
    } as any);
    
    mockFs.access.mockResolvedValueOnce(undefined); // Directory write permission
    
    // Mock files don't exist
    mockFs.stat.mockRejectedValueOnce({ code: 'ENOENT' }); // ci.yml
    mockFs.stat.mockRejectedValueOnce({ code: 'ENOENT' }); // cd.yml
    
    // Mock file writes
    mockFs.writeFile.mockResolvedValue(undefined);

    // Configure output handler for production-like settings
    outputHandler.updateOptions({
      conflictResolution: 'backup',
      createBackups: true,
      validatePermissions: true,
      dryRun: false
    });

    const result = await outputHandler.writeWorkflowFiles(
      workflowFiles,
      outputDir,
      {
        format: 'yaml',
        indentation: 2,
        includeMetadata: true,
        backupExisting: true
      }
    );

    // Verify successful operation
    expect(result.success).toBe(true);
    expect(result.filesCreated).toBe(2);
    expect(result.filesUpdated).toBe(0);
    expect(result.filesSkipped).toBe(0);
    expect(result.errors).toHaveLength(0);
    expect(result.generatedFiles).toHaveLength(2);

    // Verify files were written with correct content
    expect(mockFs.writeFile).toHaveBeenCalledTimes(2);
    
    // Check CI workflow file
    expect(mockFs.writeFile).toHaveBeenCalledWith(
      expect.stringContaining('ci.yml'),
      expect.stringContaining('# Generated by readme-to-cicd'),
      'utf8'
    );
    
    // Check CD workflow file
    expect(mockFs.writeFile).toHaveBeenCalledWith(
      expect.stringContaining('cd.yml'),
      expect.stringContaining('# Generated by readme-to-cicd'),
      'utf8'
    );

    // Verify content includes metadata
    const ciCall = mockFs.writeFile.mock.calls.find(call => 
      call[0].toString().includes('ci.yml')
    );
    expect(ciCall?.[1]).toContain('name: CI');
    expect(ciCall?.[1]).toContain('# Generated by readme-to-cicd');
  });

  it('should handle real-world conflict scenarios', async () => {
    const workflowFile: WorkflowFile = {
      filename: 'ci.yml',
      content: 'name: Updated CI\non: push\njobs:\n  test:\n    runs-on: ubuntu-latest',
      type: 'ci'
    };

    const outputDir = '.github/workflows';
    
    // Mock directory exists
    mockFs.stat.mockResolvedValueOnce({
      isDirectory: () => true
    } as any);
    
    mockFs.access.mockResolvedValueOnce(undefined);
    
    // Mock existing file
    mockFs.stat.mockResolvedValueOnce({
      mtime: new Date('2024-01-01'),
      size: 200
    } as any);
    
    // Mock reading existing file
    mockFs.readFile.mockResolvedValueOnce('name: Old CI\non: push\njobs:\n  old-test:\n    runs-on: ubuntu-latest');
    
    // Mock backup and write operations
    mockFs.copyFile.mockResolvedValue(undefined);
    mockFs.stat.mockResolvedValueOnce({ mode: 0o644 } as any); // File permissions check
    mockFs.writeFile.mockResolvedValue(undefined);

    const result = await outputHandler.writeWorkflowFiles([workflowFile], outputDir);

    expect(result.success).toBe(true);
    expect(result.filesUpdated).toBe(1);
    expect(result.backupsCreated).toBe(1);
    expect(result.backupFiles).toHaveLength(1);
    
    // Verify backup was created
    expect(mockFs.copyFile).toHaveBeenCalledWith(
      expect.stringContaining('ci.yml'),
      expect.stringMatching(/ci\.yml\.backup\.\d{4}-\d{2}-\d{2}T\d{2}-\d{2}-\d{2}/)
    );
  });

  it('should validate output directory before processing', async () => {
    const workflowFile: WorkflowFile = {
      filename: 'test.yml',
      content: 'name: Test',
      type: 'ci'
    };

    // Test directory validation
    const validResult = await outputHandler.validateOutputDirectory('.github/workflows');
    
    // Mock for validation
    mockFs.stat.mockResolvedValueOnce({
      isDirectory: () => true
    } as any);
    mockFs.access.mockResolvedValueOnce(undefined);

    const validationResult = await outputHandler.validateOutputDirectory('.github/workflows');
    expect(validationResult.valid).toBe(true);
  });
});