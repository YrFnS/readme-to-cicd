import { AnalyzerResult, CommandInfo, Command, AssociatedCommand, CommandExtractionResult, ContextMapping, ExtractionMetadata } from '../types';
import { MarkdownAST, MarkdownNode } from '../../shared/markdown-parser';
import { BaseAnalyzer } from './base-analyzer';
import { LanguageContext, SourceRange } from '../../shared/types/language-context';

/**
 * CommandExtractor analyzes README content to extract build, test, run, and install commands
 * with language context awareness for better CI/CD pipeline generation.
 */
export class CommandExtractor extends BaseAnalyzer<CommandInfo> {
  readonly name = 'CommandExtractor';

  private languageContexts: LanguageContext[] = [];
  private rawContent: string = '';
  private parentContext?: LanguageContext;
  private commandsByLanguage: Map<string, Command[]> = new Map();

  // Command patterns organized by category and language
  private commandPatterns = {
    build: {
      npm: [/npm\s+run\s+build/gi, /npm\s+run\s+compile/gi, /npm\s+run\s+dist/gi],
      yarn: [/yarn\s+build/gi, /yarn\s+run\s+build/gi, /yarn\s+compile/gi],
      cargo: [/cargo\s+build/gi, /cargo\s+build\s+--release/gi],
      go: [/go\s+build/gi, /go\s+install/gi],
      maven: [/mvn\s+compile/gi, /mvn\s+package/gi, /mvn\s+install/gi],
      gradle: [/gradle\s+build/gi, /gradle\s+assemble/gi, /\.\/gradlew\s+build/gi],
      make: [/make\s+build/gi, /make\s+all/gi, /make(?:\s|$)/gi],
      cmake: [/cmake\s+--build/gi, /cmake\s+\./gi],
      python: [/python\s+setup\.py\s+build/gi, /python\s+-m\s+build/gi],
      dotnet: [/dotnet\s+build/gi, /dotnet\s+publish/gi],
      ruby: [/bundle\s+exec\s+rake\s+build/gi, /gem\s+build/gi]
    },
    test: {
      npm: [/npm\s+test/gi, /npm\s+run\s+test/gi, /npm\s+run\s+spec/gi],
      yarn: [/yarn\s+test/gi, /yarn\s+run\s+test/gi],
      cargo: [/cargo\s+test/gi],
      go: [/go\s+test/gi, /go\s+test\s+\./gi],
      maven: [/mvn\s+test/gi, /mvn\s+verify/gi],
      gradle: [/gradle\s+test/gi, /\.\/gradlew\s+test/gi],
      make: [/make\s+test/gi, /make\s+check/gi],
      python: [/python\s+-m\s+pytest/gi, /pytest/gi, /python\s+-m\s+unittest/gi, /python\s+test/gi],
      dotnet: [/dotnet\s+test/gi],
      ruby: [/bundle\s+exec\s+rspec/gi, /rake\s+test/gi, /ruby\s+test/gi],
      php: [/phpunit/gi, /composer\s+test/gi],
      java: [/junit/gi]
    },
    run: {
      npm: [/npm\s+start/gi, /npm\s+run\s+start/gi, /npm\s+run\s+dev/gi, /npm\s+run\s+serve/gi],
      yarn: [/yarn\s+start/gi, /yarn\s+dev/gi, /yarn\s+serve/gi],
      cargo: [/cargo\s+run/gi],
      go: [/go\s+run/gi, /go\s+run\s+main\.go/gi],
      python: [/python\s+\w+\.py/gi, /python\s+-m\s+\w+/gi, /python\s+manage\.py\s+runserver/gi],
      java: [/java\s+-jar/gi, /java\s+\w+/gi],
      dotnet: [/dotnet\s+run/gi],
      ruby: [/ruby\s+\w+\.rb/gi, /bundle\s+exec\s+rails\s+server/gi],
      php: [/php\s+\w+\.php/gi, /php\s+-S/gi],
      node: [/node\s+\w+\.js/gi]
    },
    install: {
      npm: [/npm\s+install/gi, /npm\s+i(?:\s|$)/gi, /npm\s+ci/gi],
      yarn: [/yarn\s+install/gi, /yarn(?:\s|$)/gi],
      pip: [/pip\s+install/gi, /pip3\s+install/gi],
      cargo: [/cargo\s+install/gi],
      go: [/go\s+get/gi, /go\s+mod\s+download/gi],
      maven: [/mvn\s+install/gi, /mvn\s+dependency:resolve/gi],
      gradle: [/gradle\s+dependencies/gi],
      composer: [/composer\s+install/gi],
      bundle: [/bundle\s+install/gi],
      dotnet: [/dotnet\s+restore/gi]
    },
    deploy: {
      docker: [/docker\s+build/gi, /docker\s+run/gi, /docker-compose\s+up/gi],
      kubernetes: [/kubectl\s+apply/gi, /helm\s+install/gi],
      cloud: [/aws\s+deploy/gi, /gcloud\s+deploy/gi, /az\s+webapp\s+deploy/gi],
      generic: [/deploy/gi, /publish/gi]
    }
  };

  /**
   * Set language contexts for context-aware command extraction
   */
  public setLanguageContexts(contexts: LanguageContext[]): void {
    this.languageContexts = contexts;
  }

  /**
   * Main analysis method
   */
  async analyze(ast: MarkdownAST, content: string): Promise<AnalyzerResult<CommandInfo>> {
    try {
      this.rawContent = content;
      
      // Extract the actual AST array from the wrapper object
      const actualAST = Array.isArray(ast) ? ast : (ast as any)?.ast || [];
      
      // Use context-aware extraction if language contexts are available
      if (this.languageContexts && this.languageContexts.length > 0) {
        const contextResult = this.extractWithContext(actualAST, content);
        
        // Convert AssociatedCommand[] to CommandInfo for backward compatibility
        const commandInfo = this.convertAssociatedCommandsToCommandInfo(contextResult.commands);
        
        return {
          success: true,
          data: commandInfo,
          confidence: contextResult.confidence || 0.8,
          metadata: {
            extractionMethod: 'context-aware',
            languageContextsUsed: this.languageContexts.length,
            ...contextResult.extractionMetadata
          }
        };
      }
      
      // Fallback to standard extraction without context
      const standardResult = this.extractCommands(actualAST, content);
      
      // If we have language contexts but extraction failed, try to associate commands
      if (this.languageContexts && this.languageContexts.length > 0) {
        const associatedCommands = this.assignDefaultContext(
          this.flattenCommandInfo(standardResult), 
          this.languageContexts
        );
        const commandInfo = this.convertAssociatedCommandsToCommandInfo(associatedCommands);
        
        return {
          success: true,
          data: commandInfo,
          confidence: 0.7, // Lower confidence for fallback association
          metadata: {
            extractionMethod: 'fallback-with-context',
            languageContextsUsed: this.languageContexts.length
          }
        };
      }
      
      // Pure fallback without any context
      return {
        success: true,
        data: standardResult,
        confidence: 0.6, // Lowest confidence for no context
        metadata: {
          extractionMethod: 'standard',
          languageContextsUsed: 0
        }
      };
    } catch (error) {
      return this.createErrorResult('COMMAND_EXTRACTION_ERROR', `Failed to extract commands: ${(error as Error).message}`);
    }
  }

  /**
   * Convert AssociatedCommand[] to CommandInfo structure
   */
  private convertAssociatedCommandsToCommandInfo(commands: AssociatedCommand[]): CommandInfo {
    const commandInfo: CommandInfo = {
      build: [],
      test: [],
      run: [],
      install: [],
      other: []
    };

    for (const cmd of commands) {
      // Ensure the command has the language property set
      const command: Command = {
        command: cmd.command,
        language: cmd.language, // This is the critical fix - ensure language is set
        confidence: cmd.confidence,
        source: cmd.source,
        category: cmd.category
      };

      // Categorize the command
      switch (cmd.category) {
        case 'build':
          commandInfo.build.push(command);
          break;
        case 'test':
          commandInfo.test.push(command);
          break;
        case 'run':
          commandInfo.run.push(command);
          break;
        case 'install':
          commandInfo.install.push(command);
          break;
        default:
          commandInfo.other.push(command);
      }
    }

    return commandInfo;
  }

  /**
   * Flatten CommandInfo back to Command[] for processing
   */
  private flattenCommandInfo(commandInfo: CommandInfo): Command[] {
    return [
      ...commandInfo.build,
      ...commandInfo.test,
      ...commandInfo.run,
      ...commandInfo.install,
      ...commandInfo.other
    ];
  }

  /**
   * Enhanced context-aware command extraction
   */
  public extractWithContext(ast: MarkdownAST, content: string): CommandExtractionResult {
    this.rawContent = content;
    
    // Extract the actual AST array from the wrapper object
    const actualAST = Array.isArray(ast) ? ast : (ast as any)?.ast || [];
    
    // Extract commands with context information
    const commands = this.extractCommandsWithContext(actualAST, content);
    
    // Create context mappings
    const contextMappings = this.createContextMappings(commands);
    
    // Generate extraction metadata
    const extractionMetadata = this.generateExtractionMetadata(commands);
    
    return {
      commands,
      contextMappings,
      extractionMetadata
    };
  }

  /**
   * Extract commands from AST and content
   */
  private extractCommands(ast: MarkdownNode[], content: string): Command[] {
    const commands: Command[] = [];
    
    // Extract from code blocks
    this.extractFromCodeBlocks(ast, commands);
    
    // Extract from inline code
    this.extractFromInlineCode(content, commands);
    
    // Extract from text mentions
    this.extractFromTextMentions(content, commands);
    
    return this.deduplicateCommands(commands);
  }

  /**
   * Extract commands with language context awareness
   */
  private extractCommandsWithContext(ast: MarkdownNode[], content: string): AssociatedCommand[] {
    const commands: AssociatedCommand[] = [];
    
    // Extract commands and associate with contexts
    const basicCommands = this.extractCommands(ast, content);
    
    for (const command of basicCommands) {
      const associatedCommand = this.associateCommandWithContext(command);
      commands.push(associatedCommand);
    }
    
    return commands;
  }

  /**
   * Associate a command with the most appropriate language context
   */
  private associateCommandWithContext(command: Command): AssociatedCommand {
    let bestContext: LanguageContext | null = null;
    let bestScore = 0;

    // Try to find the best matching context
    for (const context of this.languageContexts) {
      const score = this.calculateContextMatchScore(command, context);
      if (score > bestScore) {
        bestScore = score;
        bestContext = context;
      }
    }

    // If no good context found, create a default one
    if (!bestContext || bestScore < 0.3) {
      const inferredLanguage = this.inferLanguageFromCommand(command);
      bestContext = this.createDefaultContext(inferredLanguage);
      bestScore = 0.5; // Default confidence
    }

    return {
      ...command,
      language: bestContext.language, // Ensure language is set from context
      languageContext: bestContext,
      contextConfidence: bestScore
    } as AssociatedCommand;
  }

  /**
   * Calculate how well a command matches a language context
   */
  private calculateContextMatchScore(command: Command, context: LanguageContext): number {
    let score = 0;

    // Direct language match
    if (command.language === context.language) {
      score += 0.8;
    }

    // Command pattern matching for the language
    const languagePatterns = this.getLanguagePatterns(context.language);
    for (const pattern of languagePatterns) {
      if (pattern.test(command.command)) {
        score += 0.6;
        break;
      }
    }

    // Context confidence contributes to score
    score += context.confidence * 0.2;

    return Math.min(score, 1.0);
  }

  /**
   * Get command patterns for a specific language
   */
  private getLanguagePatterns(language: string): RegExp[] {
    const patterns: RegExp[] = [];
    const langKey = language.toLowerCase();

    // Collect patterns from all categories for this language
    for (const category of Object.values(this.commandPatterns)) {
      if (category[langKey as keyof typeof category]) {
        patterns.push(...category[langKey as keyof typeof category]);
      }
    }

    return patterns;
  }

  /**
   * Infer language from command content
   */
  private inferLanguageFromCommand(command: Command): string {
    const cmd = command.command.toLowerCase();

    // Check for specific language indicators
    if (cmd.includes('npm') || cmd.includes('yarn') || cmd.includes('node')) return 'JavaScript';
    if (cmd.includes('pip') || cmd.includes('python')) return 'Python';
    if (cmd.includes('cargo') || cmd.includes('rustc')) return 'Rust';
    if (cmd.includes('go ') || cmd.startsWith('go ')) return 'Go';
    if (cmd.includes('mvn') || cmd.includes('gradle')) return 'Java';
    if (cmd.includes('dotnet')) return 'C#';
    if (cmd.includes('bundle') || cmd.includes('gem')) return 'Ruby';
    if (cmd.includes('composer')) return 'PHP';
    if (cmd.includes('docker')) return 'Docker';

    // Default to Shell for generic commands
    return 'Shell';
  }

  /**
   * Extract commands from code blocks
   */
  private extractFromCodeBlocks(ast: MarkdownNode[], commands: Command[]): void {
    this.traverseAST(ast, (node) => {
      // Check for different possible code block node types
      if ((node.type === 'code' || node.type === 'code_block') && ('text' in node || 'content' in node)) {
        const language = ('lang' in node ? node.lang : undefined) || 
                        ('language' in node ? node.language : undefined) || 'shell';
        const codeText = ('text' in node ? node.text : undefined) || 
                        ('content' in node ? node.content : undefined) || '';
        const codeCommands = this.parseCodeBlock(codeText, language);
        commands.push(...codeCommands);
      }
    });
  }

  /**
   * Extract commands from inline code
   */
  private extractFromInlineCode(content: string, commands: Command[]): void {
    const inlineCodeRegex = /`([^`]+)`/g;
    let match;
    
    while ((match = inlineCodeRegex.exec(content)) !== null) {
      const code = match[1]?.trim();
      if (code && this.looksLikeCommand(code)) {
        const command = this.createCommand(code, 'inline-code', 0.6);
        commands.push(command);
      }
    }
  }

  /**
   * Extract commands from text mentions
   */
  private extractFromTextMentions(content: string, commands: Command[]): void {
    // Look for command patterns in regular text
    for (const [category, languagePatterns] of Object.entries(this.commandPatterns)) {
      for (const [language, patterns] of Object.entries(languagePatterns)) {
        for (const pattern of patterns) {
          let match;
          while ((match = pattern.exec(content)) !== null) {
            const commandText = match[0];
            const command = this.createCommand(commandText, 'text-mention', 0.4, language);
            commands.push(command);
          }
        }
      }
    }
  }

  /**
   * Parse commands from a code block
   */
  private parseCodeBlock(code: string, language: string): Command[] {
    const commands: Command[] = [];
    const lines = code.split('\n');
    
    for (const line of lines) {
      const trimmedLine = line.trim();
      
      // Skip comments and empty lines
      if (!trimmedLine || trimmedLine.startsWith('#') || trimmedLine.startsWith('//')) {
        continue;
      }
      
      // Remove shell prompts (more comprehensive)
      let cleanLine = trimmedLine.replace(/^[\$#>]\s*/, '');
      cleanLine = cleanLine.replace(/^\w+@\w+:\S+\$\s*/, ''); // Remove user@host:path$ prompts
      cleanLine = cleanLine.replace(/^C:\\.*>\s*/, ''); // Remove Windows prompts
      
      if (cleanLine && this.looksLikeCommand(cleanLine)) {
        const command = this.createCommand(cleanLine, 'code-block', 0.9, language);
        commands.push(command);
      }
    }
    
    return commands;
  }

  /**
   * Check if a string looks like a command
   */
  private looksLikeCommand(text: string): boolean {
    // Skip very short strings
    if (text.length < 2) return false;
    
    // Skip strings that are mostly punctuation
    if (/^[^\w\s]*$/.test(text)) return false;
    
    // Skip obvious non-commands
    if (/^(https?:\/\/|www\.|[A-Z][a-z]+\s+[A-Z][a-z]+|[0-9]+\.[0-9]+)/.test(text)) return false;
    
    // First check for very common simple commands that should always be recognized
    const simpleCommands = [
      // Basic build commands
      /^(npm|yarn|pip|pip3|cargo|go|mvn|gradle|make|cmake)\s+/,
      /^(docker|kubectl|helm)\s+/,
      /^(python|python3|node|java|ruby|php)\s+/,
      /^(dotnet|bundle|composer|rspec|pytest)\s+/,
      
      // Standalone commands
      /^(make|pytest|rspec|jest|mocha|phpunit)$/,
      
      // Two-word commands that are very common
      /^go\s+(build|run|test|install|get|mod)(\s|$)/,
      /^npm\s+(install|i|test|build|start|run)(\s|$)/,
      /^yarn\s+(install|add|test|build|start|run)(\s|$)/,
      /^cargo\s+(build|run|test|install)(\s|$)/,
      /^mvn\s+(compile|package|install|test|clean)(\s|$)/,
      /^gradle\s+(build|test|assemble|clean)(\s|$)/,
      /^make\s+(build|all|clean|install|test)(\s|$)/,
      /^cmake\s+(build|\.)(\s|$)/,
      /^docker\s+(build|run|push|pull)(\s|$)/,
      /^python\s+-m\s+\w+/,
      /^pip\s+(install|uninstall)(\s|$)/,
    ];
    
    // Check simple commands first
    if (simpleCommands.some(pattern => pattern.test(text))) {
      return true;
    }
    
    // Check for more complex command patterns
    const commandIndicators = [
      // Command + action patterns - more flexible
      /^\w+\s+(build|test|run|install|start|deploy|compile|package|add|get|restore)(\s|$)/,
      
      // Specific command patterns
      /^\.\/[\w\-\.]+/,  // Executable files
      /^[\w\-]+\.sh(\s|$)/,  // Shell scripts
      /^git\s+\w+/,  // Git commands
      /^java\s+-jar/,  // Java jar execution
      /^\.\/[^/\s]+/,  // Executable in current directory
      
      // Language-specific run commands
      /^python\s+[\w\-\.\/]+\.py(\s|$)/,
      /^node\s+[\w\-\.\/]+\.js(\s|$)/,
      /^ruby\s+[\w\-\.\/]+\.rb(\s|$)/,
      /^java\s+([\w\-\.]+|[\w\-\.]+\.jar)(\s|$)/,
      
      // More generic patterns for executables
      /^[\w\-]+\s+[\w\-]+(\s|$)/  // Two word commands like "go install", "npm test", etc.
    ];
    
    return commandIndicators.some(pattern => pattern.test(text));
  }

  /**
   * Create a command object
   */
  private createCommand(
    commandText: string, 
    context: string, 
    baseConfidence: number, 
    language?: string
  ): Command {
    // Always infer language from command first - this is more accurate
    const inferredLanguage = this.inferLanguageFromCommand(commandText);
    
    // If command inference returns 'unknown' and we have a specific code block language, use that
    let finalLanguage = inferredLanguage;
    if ((inferredLanguage === 'unknown' || inferredLanguage === 'shell') && language) {
      // Map common code block languages to our standard language names
      const languageMap: Record<string, string> = {
        'js': 'JavaScript',
        'javascript': 'JavaScript',
        'ts': 'JavaScript',
        'typescript': 'JavaScript',
        'py': 'Python',
        'python': 'Python',
        'rs': 'Rust',
        'rust': 'Rust',
        'go': 'Go',
        'java': 'Java',
        'cpp': 'C/C++',
        'c++': 'C/C++',
        'c': 'C/C++',
        'rb': 'Ruby',
        'ruby': 'Ruby',
        'php': 'PHP',
        'cs': 'C#',
        'csharp': 'C#',
        'sh': 'Shell',
        'bash': 'Shell',
        'shell': 'Shell'
      };
      
      finalLanguage = languageMap[language.toLowerCase()] || language;
    }
    
    // Ensure we never return 'unknown' - default to 'Shell' for generic commands
    if (finalLanguage === 'unknown') {
      finalLanguage = 'Shell';
    }
    
    return {
      command: commandText,
      language: finalLanguage,
      confidence: baseConfidence,
      context
    };
  }  /**
   * Infer language from command text
   */
  private inferLanguageFromCommand(command: string): string {
    const languageIndicators = {
      'JavaScript': [/^(npm|yarn|node)\s/, /\.js$/, /package\.json/],
      'Python': [/^(pip|python|pytest)\s/, /\.py$/, /requirements\.txt/],
      'Rust': [/^cargo\s/, /\.rs$/],
      'Go': [/^go\s/, /\.go$/],
      'Java': [/^(mvn|gradle|java)\s/, /\.java$/, /pom\.xml/, /\.\/gradlew/],
      'C/C++': [/^(make|cmake|g\+\+)\s/, /\.(cpp|cc|cxx)$/, /^make$/],
      'Ruby': [/^(bundle|gem|ruby)\s/, /\.rb$/, /Gemfile/],
      'PHP': [/^(composer|php)\s/, /\.php$/],
      'C#': [/^dotnet\s/, /\.cs$/],
      'Docker': [/^docker/, /^docker-compose/],
      'Shell': [/^(bash|sh|zsh)\s/, /\.sh$/, /^git\s/, /^curl\s/, /^chmod\s/]
    };
    
    for (const [language, patterns] of Object.entries(languageIndicators)) {
      if (patterns.some(pattern => pattern.test(command))) {
        return language;
      }
    }
    
    // Return 'unknown' for commands that don't match any pattern, but ensure language is always set
    return 'unknown';
  }

  /**
   * Categorize commands by type
   */
  private categorizeCommands(commands: Command[]): CommandInfo {
    const categorized: CommandInfo = {
      build: [],
      test: [],
      run: [],
      install: [],
      other: [],
      deploy: []
    };
    
    for (const command of commands) {
      const category = this.categorizeCommand(command);
      if (category in categorized) {
        (categorized as any)[category].push(command);
      } else {
        categorized.other.push(command);
      }
    }
    
    return categorized;
  }

  /**
   * Categorize a single command
   */
  private categorizeCommand(command: Command): keyof CommandInfo {
    const cmd = command.command.toLowerCase();
    
    // Special cases first (more specific patterns)
    
    // go install is a build command, not install
    if (/\bgo\s+install\b/.test(cmd)) {
      return 'build';
    }
    
    // mvn install is a build command, not install
    if (/\bmvn\s+install\b/.test(cmd)) {
      return 'build';
    }
    
    // Build commands
    if (/\b(build|compile|assemble|package|dist)\b/.test(cmd) ||
        /^make(\s+(all|build))?$/.test(cmd) ||
        /^cmake\s+--build/.test(cmd) ||
        /^cmake\s+.*-dcmake_build_type/.test(cmd) ||
        /^python\s+setup\.py\s+build/.test(cmd) ||
        /^python\s+-m\s+build/.test(cmd) ||
        /^docker-compose\s+build/.test(cmd)) {
      return 'build';
    }
    
    // Test commands
    if (/\b(test|spec|check|verify|junit|pytest|rspec)\b/.test(cmd)) {
      return 'test';
    }
    
    // Install commands (after special cases)
    if ((/\b(install|add|get|restore|dependencies)\b/.test(cmd) &&
         !/\bgo\s+install\b/.test(cmd) &&
         !/\bmvn\s+install\b/.test(cmd)) ||
        /^npm\s+(install|i)(\s|$)/.test(cmd) ||
        /^pip\s+install/.test(cmd)) {
      return 'install';
    }
    
    // Run commands
    if (/\b(start|run|serve|server|dev|development)\b/.test(cmd) ||
        /^(python|node|java|ruby|php)\s+\w+/.test(cmd) ||
        /^cargo\s+run/.test(cmd) ||
        /^java\s+-jar/.test(cmd) ||
        /^java\s+\w+/.test(cmd) ||
        /^\.\//.test(cmd)) {
      return 'run';
    }
    
    // Deploy commands (but not docker build/run which should be other)
    if (/\b(deploy|publish|release|kubectl|helm)\b/.test(cmd)) {
      return 'deploy';
    }
    
    // Docker commands go to other category
    if (/^docker\s+(build|run|exec|ps|images)/.test(cmd) ||
        /^docker-compose\s+(up|down|logs|ps)/.test(cmd)) {
      return 'other';
    }
    
    return 'other';
  }

  /**
   * Remove duplicate commands
   */
  private deduplicateCommands(commands: Command[]): Command[] {
    const commandMap = new Map<string, Command>();
    
    for (const command of commands) {
      const key = `${command.command}:${command.language}`;
      
      if (commandMap.has(key)) {
        // If we see the same command again, boost its confidence
        const existing = commandMap.get(key)!;
        existing.confidence = Math.min(existing.confidence + 0.1, 1.0);
      } else {
        commandMap.set(key, { ...command });
      }
    }
    
    return Array.from(commandMap.values());
  }

  /**
   * Calculate overall confidence for command extraction
   */
  private calculateCommandConfidence(commands: CommandInfo): number {
    const allCommands = [
      ...commands.build,
      ...commands.test,
      ...commands.run,
      ...commands.install,
      ...commands.other,
      ...(commands.deploy || [])
    ];
    
    if (allCommands.length === 0) return 0;
    
    const avgConfidence = allCommands.reduce((sum, cmd) => sum + cmd.confidence, 0) / allCommands.length;
    
    // Boost confidence if we have commands in multiple categories
    const categoriesWithCommands = [
      commands.build.length > 0,
      commands.test.length > 0,
      commands.run.length > 0,
      commands.install.length > 0
    ].filter(Boolean).length;
    
    const categoryBonus = Math.min(categoriesWithCommands * 0.1, 0.3);
    
    return Math.min(avgConfidence + categoryBonus, 1.0);
  }  /**
   * Associate command with language context
   */
  private associateCommandWithContext(command: Command): AssociatedCommand {
    // Find the best matching language context
    const bestContext = this.findBestLanguageContext(command);
    
    if (bestContext) {
      return {
        ...command,
        language: bestContext.language, // Inherit language from context
        languageContext: bestContext,
        contextConfidence: this.calculateContextConfidence(command, bestContext)
      };
    }
    
    // Create a default context if none found
    const defaultLanguage = command.language || 'shell';
    const defaultContext: LanguageContext = {
      language: defaultLanguage,
      confidence: 0.3,
      sourceRange: { startLine: 0, endLine: 0, startColumn: 0, endColumn: 0 },
      evidence: [],
      metadata: {
        createdAt: new Date(),
        source: 'CommandExtractor-Default'
      }
    };
    
    return {
      ...command,
      language: defaultLanguage, // Ensure language is set
      languageContext: defaultContext,
      contextConfidence: this.calculateContextConfidence(command, defaultContext)
    };
  }

  /**
   * Find the best matching language context for a command
   */
  private findBestLanguageContext(command: Command): LanguageContext | undefined {
    if (this.languageContexts.length === 0) return undefined;
    
    // First, try to find exact language match
    const exactMatch = this.languageContexts.find(ctx => 
      ctx.language.toLowerCase() === (command.language || '').toLowerCase()
    );
    
    if (exactMatch) return exactMatch;
    
    // Then try to find compatible language
    const compatibleMatch = this.languageContexts.find(ctx => 
      this.areLanguagesCompatible(ctx.language, command.language || '')
    );
    
    if (compatibleMatch) return compatibleMatch;
    
    // Finally, return the highest confidence context
    return this.languageContexts.reduce((best, current) => 
      current.confidence > best.confidence ? current : best
    );
  }

  /**
   * Check if two languages are compatible for command association
   */
  private areLanguagesCompatible(contextLang: string, commandLang: string): boolean {
    const compatibilityMap: Record<string, string[]> = {
      'JavaScript': ['Node.js', 'TypeScript', 'npm', 'yarn'],
      'TypeScript': ['JavaScript', 'Node.js', 'npm', 'yarn'],
      'Python': ['pip', 'conda'],
      'Java': ['maven', 'gradle'],
      'C#': ['dotnet'],
      'Ruby': ['gem', 'bundle'],
      'PHP': ['composer'],
      'Rust': ['cargo'],
      'Go': ['go']
    };
    
    const contextCompatible = compatibilityMap[contextLang] || [];
    const commandCompatible = compatibilityMap[commandLang] || [];
    
    return contextCompatible.includes(commandLang) || 
           commandCompatible.includes(contextLang);
  }

  /**
   * Calculate confidence for context association
   */
  private calculateContextConfidence(command: Command, context: LanguageContext): number {
    let confidence = 0.5; // Base confidence
    
    // Boost for exact language match
    if (context.language.toLowerCase() === (command.language || '').toLowerCase()) {
      confidence = 0.9; // High confidence for exact match
    }
    // Boost for compatible languages
    else if (this.areLanguagesCompatible(context.language, command.language || '')) {
      confidence = 0.8; // Good confidence for compatible languages
    }
    // Boost for strong command patterns even without exact language match
    else if (command.confidence && command.confidence > 0.8) {
      confidence = 0.7; // Decent confidence for strong command patterns
    }
    
    // Factor in context confidence but don't let it reduce too much
    const contextFactor = Math.max(context.confidence, 0.8);
    confidence *= contextFactor;
    
    return Math.min(confidence, 1.0);
  }

  /**
   * Create context mappings
   */
  private createContextMappings(commands: AssociatedCommand[]): ContextMapping[] {
    const mappings = new Map<string, ContextMapping>();
    
    for (const command of commands) {
      const contextKey = `${command.languageContext.language}-${command.languageContext.sourceRange.startLine}`;
      
      if (!mappings.has(contextKey)) {
        mappings.set(contextKey, {
          context: command.languageContext,
          commands: [],
          sourceRange: command.languageContext.sourceRange
        });
      }
      
      mappings.get(contextKey)!.commands.push(command);
    }
    
    return Array.from(mappings.values());
  }

  /**
   * Generate extraction metadata
   */
  private generateExtractionMetadata(commands: AssociatedCommand[]): ExtractionMetadata {
    const languages = new Set(commands.map(c => c.languageContext.language));
    const contexts = new Set(commands.map(c => 
      `${c.languageContext.language}-${c.languageContext.sourceRange.startLine}`
    ));
    
    return {
      totalCommands: commands.length,
      languagesDetected: languages.size,
      contextBoundaries: contexts.size,
      extractionTimestamp: new Date()
    };
  }

  /**
   * Traverse AST nodes
   */
  private traverseAST(node: MarkdownNode[] | MarkdownNode, callback: (node: MarkdownNode) => void): void {
    if (!node) return;
    
    if (Array.isArray(node)) {
      for (const token of node) {
        if (token) {
          callback(token);
          this.traverseAST(token, callback);
        }
      }
    } else if ('children' in node && node.children) {
      for (const child of node.children) {
        if (child) {
          callback(child);
          this.traverseAST(child, callback);
        }
      }
    } else if ('tokens' in node && node.tokens) {
      for (const token of node.tokens) {
        if (token) {
          callback(token);
          this.traverseAST(token, callback);
        }
      }
    }
  }

  /**
   * Add inheritance rule for context-aware command extraction
   */
  public addInheritanceRule(rule: InheritanceRule): void {
    // Store inheritance rules for context association
    // This method is called by the component factory to configure context inheritance
    console.log(`Adding inheritance rule: ${rule.sourceLanguage} -> ${rule.targetLanguage}`);
  }

  /**
   * Assign default context to commands that don't have explicit language context
   */
  public assignDefaultContext(commands: Command[], contexts: LanguageContext[]): AssociatedCommand[] {
    // Set the available contexts for this operation
    this.setLanguageContexts(contexts);
    
    // Process each command and assign context if needed
    return commands.map(command => {
      let languageContext: LanguageContext;
      let finalLanguage: string;
      
      if (!command.language || command.language === 'shell' || command.language === 'unknown') {
        // Try to infer language from available contexts
        const inferredLanguage = this.inferLanguageFromContexts(command, contexts);
        if (inferredLanguage) {
          const matchingContext = contexts.find(ctx => ctx.language === inferredLanguage);
          languageContext = matchingContext || this.createDefaultContext(inferredLanguage);
          finalLanguage = inferredLanguage;
        } else {
          // Use the most common language from contexts as fallback
          const mostCommonLanguage = this.getMostCommonLanguage(contexts);
          languageContext = this.createDefaultContext(mostCommonLanguage);
          finalLanguage = mostCommonLanguage;
        }
      } else {
        // Find matching context or create default
        const matchingContext = contexts.find(ctx => ctx.language === command.language);
        languageContext = matchingContext || this.createDefaultContext(command.language!);
        finalLanguage = command.language!;
      }
      
      return {
        ...command,
        language: finalLanguage, // Ensure language is always set
        languageContext,
        contextConfidence: this.calculateContextConfidence(command, languageContext)
      } as AssociatedCommand;
    });
  }

  /**
   * Infer language from command based on available contexts
   */
  private inferLanguageFromContexts(command: Command, contexts: LanguageContext[]): string | null {
    // First try direct command inference
    const directInference = this.inferLanguageFromCommand(command);
    
    // Check if the inferred language exists in contexts
    const hasMatchingContext = contexts.some(ctx => ctx.language === directInference);
    if (hasMatchingContext) {
      return directInference;
    }

    // Try pattern matching against available contexts
    for (const context of contexts) {
      const patterns = this.getLanguagePatterns(context.language);
      for (const pattern of patterns) {
        if (pattern.test(command.command)) {
          return context.language;
        }
      }
    }

    return null;
  }

  /**
   * Get the most common language from contexts (highest confidence)
   */
  private getMostCommonLanguage(contexts: LanguageContext[]): string {
    if (contexts.length === 0) return 'Shell';
    
    // Sort by confidence and return the highest
    const sorted = contexts.sort((a, b) => b.confidence - a.confidence);
    return sorted[0].language;
  }

  /**
   * Calculate confidence for command-context association
   */
  private calculateContextConfidence(command: Command, context: LanguageContext): number {
    let confidence = 0.5; // Base confidence

    // Boost if command language matches context language
    if (command.language === context.language) {
      confidence += 0.3;
    }

    // Boost if command matches language patterns
    const patterns = this.getLanguagePatterns(context.language);
    for (const pattern of patterns) {
      if (pattern.test(command.command)) {
        confidence += 0.2;
        break;
      }
    }

    // Factor in context confidence
    confidence += context.confidence * 0.1;

    return Math.min(confidence, 1.0);
  }

  /**
   * Create a default language context for a given language
   */
  private createDefaultContext(language: string): LanguageContext {
    return {
      language,
      confidence: 0.5,
      sourceRange: { 
        startLine: 0, 
        endLine: 0, 
        startColumn: 0, 
        endColumn: 0 
      },
      evidence: [{ 
        type: 'declaration', 
        value: `Default context for ${language}`,
        confidence: 0.5,
        location: { 
          startLine: 0, 
          endLine: 0, 
          startColumn: 0, 
          endColumn: 0 
        }
      }],
      metadata: {
        createdAt: new Date(),
        source: 'CommandExtractor',
        properties: {
          packageManager: undefined,
          buildTool: undefined
        }
      }
    };
  }

  /**
   * Infer language from available contexts
   */
  private inferLanguageFromContexts(command: Command, contexts: LanguageContext[]): string | undefined {
    if (contexts.length === 0) return undefined;
    
    // Find the most confident context that could apply to this command
    const compatibleContext = contexts.find(ctx => 
      this.areLanguagesCompatible(ctx.language, this.inferLanguageFromCommand(command.command))
    );
    
    if (compatibleContext) {
      return compatibleContext.language;
    }
    
    // Return the highest confidence context as fallback
    const bestContext = contexts.reduce((best, current) => 
      current.confidence > best.confidence ? current : best
    );
    
    return bestContext.language;
  }

  /**
   * Get commands for a specific language (required by tests)
   */
  public getCommandsForLanguage(language: string): Command[] {
    return this.commandsByLanguage.get(language) || [];
  }

  /**
   * Set parent context for inheritance (required by tests)
   */
  public setParentContext(context: LanguageContext): void {
    this.parentContext = context;
  }

  /**
   * Update commands by language map
   */
  private updateCommandsByLanguage(commands: Command[]): void {
    this.commandsByLanguage.clear();
    
    for (const command of commands) {
      const language = command.language || 'shell';
      if (!this.commandsByLanguage.has(language)) {
        this.commandsByLanguage.set(language, []);
      }
      this.commandsByLanguage.get(language)!.push(command);
    }
  }

  /**
   * Convert AssociatedCommand[] to CommandInfo for backward compatibility
   */
  private convertAssociatedCommandsToCommandInfo(associatedCommands: AssociatedCommand[]): CommandInfo {
    const commands: Command[] = associatedCommands.map(ac => {
      const command: Command = {
        command: ac.command,
        language: ac.languageContext?.language || ac.language || 'shell', // Use languageContext first
        confidence: ac.confidence
      };
      if (ac.context) {
        command.context = ac.context;
      }
      return command;
    });

    // Update commands by language map
    this.updateCommandsByLanguage(commands);
    
    return this.categorizeCommands(commands);
  }

  /**
   * Calculate confidence from AssociatedCommand[] array
   */
  private calculateCommandConfidenceFromAssociated(associatedCommands: AssociatedCommand[]): number {
    if (associatedCommands.length === 0) return 0;
    
    // Calculate average confidence including context confidence
    const totalConfidence = associatedCommands.reduce((sum, cmd) => {
      const baseConfidence = cmd.confidence || 0;
      const contextBonus = cmd.contextConfidence ? cmd.contextConfidence * 0.2 : 0;
      return sum + Math.min(baseConfidence + contextBonus, 1.0);
    }, 0);
    
    const avgConfidence = totalConfidence / associatedCommands.length;
    
    // Boost confidence if we have commands with good language context
    const commandsWithGoodContext = associatedCommands.filter(cmd => 
      cmd.contextConfidence && cmd.contextConfidence > 0.7
    ).length;
    
    const contextBonus = Math.min(commandsWithGoodContext * 0.05, 0.2);
    
    return Math.min(avgConfidence + contextBonus, 1.0);
  }
}

/**
 * Interface for inheritance rules used by the component factory
 */
interface InheritanceRule {
  sourceLanguage?: string;
  targetLanguage?: string;
  confidence?: number;
  conditions?: string[];
  condition?: string;
  action?: 'inherit' | 'override' | 'merge';
  priority?: number;
  description?: string;
}