/**
 * YAML Renderer for converting structured data to formatted YAML
 */

import * as yaml from 'js-yaml';
import { FormattingOptions, RenderingResult, RenderingMetadata } from './renderer-types';
import { WorkflowTemplate } from '../types';

/**
 * YAML Renderer class with yaml library integration
 */
export class YAMLRenderer {
  private options: FormattingOptions;

  constructor(options: FormattingOptions) {
    this.options = options;
  }

  /**
   * Render workflow template to YAML string
   */
  renderWorkflow(workflow: WorkflowTemplate): RenderingResult {
    const startTime = Date.now();
    const warnings: string[] = [];

    try {
      // Convert workflow template to GitHub Actions format
      const githubWorkflow = this.convertToGitHubActionsFormat(workflow);
      
      // Generate YAML with configured options
      const yamlContent = yaml.dump(githubWorkflow, {
        indent: this.options.yamlConfig.indent,
        lineWidth: this.options.yamlConfig.lineWidth,
        noRefs: this.options.yamlConfig.noRefs,
        noCompatMode: this.options.yamlConfig.noCompatMode,
        condenseFlow: this.options.yamlConfig.condenseFlow,
        quotingType: this.options.yamlConfig.quotingType === 'auto' ? undefined : this.options.yamlConfig.quotingType,
        forceQuotes: this.options.yamlConfig.forceQuotes,
        sortKeys: this.options.yamlConfig.sortKeys,
        skipInvalid: false,
        flowLevel: -1
      });

      // Apply formatting and comments
      let formattedYaml = this.formatYAML(yamlContent);
      
      if (this.options.commentConfig.enabled) {
        formattedYaml = this.injectComments(formattedYaml, workflow);
      }

      // Calculate metadata
      const renderingTime = Date.now() - startTime;
      const metadata: RenderingMetadata = {
        linesCount: formattedYaml.split('\n').length,
        charactersCount: formattedYaml.length,
        renderingTime,
        optimizationsApplied: this.getAppliedOptimizations(workflow)
      };

      return {
        yaml: formattedYaml,
        metadata,
        warnings
      };
    } catch (error) {
      throw new Error(`YAML rendering failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Add comments to YAML content
   */
  injectComments(yamlContent: string, workflow: WorkflowTemplate): string {
    // If comments are disabled, return original content
    if (!this.options.commentConfig.enabled) {
      return yamlContent;
    }

    const lines = yamlContent.split('\n');
    const commentedLines: string[] = [];

    // Add generation info comment at the top
    if (this.options.commentConfig.includeGenerationInfo) {
      commentedLines.push('# This workflow was automatically generated by README-to-CICD');
      commentedLines.push(`# Generated at: ${new Date().toISOString()}`);
      commentedLines.push(`# Workflow type: ${workflow.type}`);
      commentedLines.push('');
    }

    let inJobsSection = false;
    let currentJobName = '';
    let inStepsSection = false;

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const trimmedLine = line.trim();

      // Add workflow-level comments
      if (trimmedLine.startsWith('name:')) {
        commentedLines.push(`# ${workflow.name} - ${this.getWorkflowDescription(workflow)}`);
      }

      // Add trigger comments
      if (trimmedLine === 'on:') {
        commentedLines.push('# Workflow triggers');
      }

      // Add jobs section comment
      if (trimmedLine === 'jobs:') {
        inJobsSection = true;
        commentedLines.push('# Workflow jobs');
      }

      // Add job-level comments
      if (inJobsSection && trimmedLine.endsWith(':') && !trimmedLine.includes(' ') && trimmedLine !== 'jobs:') {
        currentJobName = trimmedLine.replace(':', '');
        const job = workflow.jobs.find(j => this.sanitizeJobName(j.name) === currentJobName);
        if (job && this.options.commentConfig.includeStepDescriptions) {
          commentedLines.push(`  # Job: ${job.name}`);
        }
      }

      // Add steps section comment
      if (trimmedLine === 'steps:') {
        inStepsSection = true;
        if (this.options.commentConfig.includeStepDescriptions) {
          commentedLines.push('    # Job steps');
        }
      }

      // Add step-level comments
      if (inStepsSection && trimmedLine.startsWith('- name:')) {
        const stepName = trimmedLine.replace('- name:', '').trim().replace(/['"]/g, '');
        if (this.options.commentConfig.includeStepDescriptions) {
          const stepDescription = this.getStepDescription(stepName);
          if (stepDescription) {
            commentedLines.push(`      # ${stepDescription}`);
          }
        }
      }

      // Add custom comments
      for (const [pattern, comment] of Object.entries(this.options.commentConfig.customComments)) {
        if (trimmedLine.includes(pattern)) {
          commentedLines.push(`${line.match(/^\s*/)?.[0] || ''}# ${comment}`);
        }
      }

      commentedLines.push(line);

      // Add blank lines for better readability
      if (this.options.addBlankLines) {
        if (trimmedLine === 'on:' || trimmedLine === 'jobs:' || 
            (inJobsSection && trimmedLine.endsWith(':') && !trimmedLine.includes(' '))) {
          commentedLines.push('');
        }
      }
    }

    return commentedLines.join('\n');
  }

  /**
   * Format YAML with proper indentation and structure
   */
  formatYAML(yamlContent: string): string {
    const lines = yamlContent.split('\n');
    const formattedLines: string[] = [];

    for (const line of lines) {
      // Remove trailing whitespace
      const trimmedLine = line.trimEnd();
      
      // Skip empty lines at the beginning
      if (formattedLines.length === 0 && trimmedLine === '') {
        continue;
      }

      formattedLines.push(trimmedLine);
    }

    // Remove trailing empty lines
    while (formattedLines.length > 0 && formattedLines[formattedLines.length - 1] === '') {
      formattedLines.pop();
    }

    // Ensure file ends with newline
    if (formattedLines.length > 0) {
      formattedLines.push('');
    }

    return formattedLines.join('\n');
  }

  /**
   * Validate YAML syntax
   */
  validateYAMLSyntax(yamlContent: string): { isValid: boolean; error?: string } {
    try {
      yaml.load(yamlContent);
      return { isValid: true };
    } catch (error) {
      return { 
        isValid: false, 
        error: error instanceof Error ? error.message : 'Unknown YAML syntax error' 
      };
    }
  }

  /**
   * Convert workflow template to GitHub Actions format
   */
  private convertToGitHubActionsFormat(workflow: WorkflowTemplate): any {
    const githubWorkflow: any = {
      name: workflow.name
    };

    // Add triggers
    if (workflow.triggers) {
      githubWorkflow.on = this.convertTriggers(workflow.triggers);
    }

    // Add permissions
    if (workflow.permissions) {
      githubWorkflow.permissions = workflow.permissions;
    }

    // Add concurrency
    if (workflow.concurrency) {
      const concurrency: any = { ...workflow.concurrency };
      if (concurrency.cancelInProgress !== undefined) {
        concurrency['cancel-in-progress'] = concurrency.cancelInProgress;
        delete concurrency.cancelInProgress;
      }
      githubWorkflow.concurrency = concurrency;
    }

    // Add defaults
    if (workflow.defaults) {
      githubWorkflow.defaults = workflow.defaults;
    }

    // Add environment
    if (workflow.environment) {
      githubWorkflow.env = workflow.environment;
    }

    // Convert jobs
    githubWorkflow.jobs = {};
    for (const job of workflow.jobs) {
      const jobKey = this.sanitizeJobName(job.name);
      githubWorkflow.jobs[jobKey] = this.convertJob(job);
    }

    return githubWorkflow;
  }

  /**
   * Convert triggers to GitHub Actions format
   */
  private convertTriggers(triggers: any): any {
    const converted: any = {};

    if (triggers.push) {
      converted.push = triggers.push;
    }

    if (triggers.pullRequest) {
      converted.pull_request = triggers.pullRequest;
    }

    if (triggers.schedule) {
      converted.schedule = triggers.schedule;
    }

    if (triggers.workflowDispatch) {
      converted.workflow_dispatch = triggers.workflowDispatch;
    }

    if (triggers.release) {
      converted.release = triggers.release;
    }

    if (triggers.issues) {
      converted.issues = triggers.issues;
    }

    if (triggers.pullRequestTarget) {
      converted.pull_request_target = triggers.pullRequestTarget;
    }

    if (triggers.repositoryDispatch) {
      converted.repository_dispatch = triggers.repositoryDispatch;
    }

    return converted;
  }

  /**
   * Convert job template to GitHub Actions format
   */
  private convertJob(job: any): any {
    const converted: any = {
      'runs-on': job.runsOn
    };

    if (job.strategy) {
      // Convert strategy matrix with proper GitHub Actions format
      const strategy: any = { ...job.strategy };
      if (strategy.failFast !== undefined) {
        strategy['fail-fast'] = strategy.failFast;
        delete strategy.failFast;
      }
      if (strategy.maxParallel !== undefined) {
        strategy['max-parallel'] = strategy.maxParallel;
        delete strategy.maxParallel;
      }
      converted.strategy = strategy;
    }

    if (job.needs && job.needs.length > 0) {
      converted.needs = job.needs;
    }

    if (job.if) {
      converted.if = job.if;
    }

    if (job.environment) {
      converted.environment = job.environment;
    }

    if (job.permissions) {
      converted.permissions = job.permissions;
    }

    if (job.timeout) {
      converted['timeout-minutes'] = job.timeout;
    }

    if (job.continueOnError) {
      converted['continue-on-error'] = job.continueOnError;
    }

    if (job.outputs) {
      converted.outputs = job.outputs;
    }

    // Convert steps
    converted.steps = job.steps.map((step: any) => this.convertStep(step));

    return converted;
  }

  /**
   * Convert step template to GitHub Actions format
   */
  private convertStep(step: any): any {
    const converted: any = {
      name: step.name
    };

    if (step.id) {
      converted.id = step.id;
    }

    if (step.uses) {
      converted.uses = step.uses;
    }

    if (step.run) {
      converted.run = step.run;
    }

    if (step.with) {
      converted.with = step.with;
    }

    if (step.env) {
      converted.env = step.env;
    }

    if (step.if) {
      converted.if = step.if;
    }

    if (step.continueOnError) {
      converted['continue-on-error'] = step.continueOnError;
    }

    if (step.timeout) {
      converted['timeout-minutes'] = step.timeout;
    }

    if (step.shell) {
      converted.shell = step.shell;
    }

    if (step.workingDirectory) {
      converted['working-directory'] = step.workingDirectory;
    }

    return converted;
  }

  /**
   * Sanitize job name for use as YAML key
   */
  private sanitizeJobName(name: string): string {
    return name
      .toLowerCase()
      .replace(/[^a-z0-9-_]/g, '-')
      .replace(/-+/g, '-')
      .replace(/^-|-$/g, '');
  }

  /**
   * Get workflow description based on type
   */
  private getWorkflowDescription(workflow: WorkflowTemplate): string {
    const descriptions = {
      ci: 'Continuous Integration workflow for building and testing',
      cd: 'Continuous Deployment workflow for releasing to production',
      release: 'Release workflow for versioning and publishing',
      maintenance: 'Maintenance workflow for dependency updates and security patches',
      security: 'Security workflow for vulnerability scanning and compliance',
      performance: 'Performance workflow for benchmarking and monitoring'
    };

    return descriptions[workflow.type] || 'Automated workflow';
  }

  /**
   * Get step description for common step patterns
   */
  private getStepDescription(stepName: string): string | null {
    const patterns = {
      'checkout': 'Check out repository code',
      'setup': 'Set up runtime environment',
      'install': 'Install project dependencies',
      'build': 'Build the project',
      'test': 'Run automated tests',
      'lint': 'Run code quality checks',
      'deploy': 'Deploy to target environment',
      'cache': 'Cache dependencies for faster builds',
      'upload': 'Upload build artifacts',
      'download': 'Download build artifacts'
    };

    for (const [pattern, description] of Object.entries(patterns)) {
      if (stepName.toLowerCase().includes(pattern)) {
        return description;
      }
    }

    return null;
  }

  /**
   * Get applied optimizations for metadata
   */
  private getAppliedOptimizations(workflow: WorkflowTemplate): string[] {
    const optimizations: string[] = [];

    // Check for caching
    const hasCaching = workflow.jobs.some(job => 
      job.steps.some(step => 
        step.uses?.includes('actions/cache') || 
        (step.with && 'cache' in step.with)
      )
    );
    if (hasCaching) {
      optimizations.push('dependency-caching');
    }

    // Check for matrix builds
    const hasMatrix = workflow.jobs.some(job => job.strategy?.matrix);
    if (hasMatrix) {
      optimizations.push('matrix-builds');
    }

    // Check for parallel jobs
    if (workflow.jobs.length > 1) {
      optimizations.push('parallel-execution');
    }

    // Check for conditional execution
    const hasConditions = workflow.jobs.some(job => 
      job.if || job.steps.some(step => step.if)
    );
    if (hasConditions) {
      optimizations.push('conditional-execution');
    }

    return optimizations;
  }
}